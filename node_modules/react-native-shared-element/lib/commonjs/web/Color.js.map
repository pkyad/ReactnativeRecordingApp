{"version":3,"sources":["Color.ts"],"names":["parseColor","color","Array","isArray","cache","p","parseInt","replace","exec","Error","formatColor","interpolateColor","color1","color2","position","map","c","i"],"mappings":"iKAEO,QAASA,CAAAA,UAAT,CAAoBC,KAApB,CAAkD,CACvD,GAAIC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,CAA0B,MAAOA,CAAAA,KAAP,CAC1B,GAAIG,CAAAA,KAAJ,CACA,GAAMC,CAAAA,CAAC,CAAGC,QAAV,CACAL,KAAK,CAAGA,KAAK,CAACM,OAAN,CAAc,KAAd,CAAqB,EAArB,CAAR,CAGA,GAAKH,KAAK,CAAG,iDAAiDI,IAAjD,CAAsDP,KAAtD,CAAb,CACE,MAAO,CAACI,CAAC,CAACD,KAAK,CAAC,CAAD,CAAN,CAAW,EAAX,CAAF,CAAkBC,CAAC,CAACD,KAAK,CAAC,CAAD,CAAN,CAAW,EAAX,CAAnB,CAAmCC,CAAC,CAACD,KAAK,CAAC,CAAD,CAAN,CAAW,EAAX,CAApC,CAAoD,CAApD,CAAP,CADF,IAGK,IAAKA,KAAK,CAAG,wCAAwCI,IAAxC,CAA6CP,KAA7C,CAAb,CACH,MAAO,CACLI,CAAC,CAACD,KAAK,CAAC,CAAD,CAAN,CAAW,EAAX,CAAD,CAAkB,EADb,CAELC,CAAC,CAACD,KAAK,CAAC,CAAD,CAAN,CAAW,EAAX,CAAD,CAAkB,EAFb,CAGLC,CAAC,CAACD,KAAK,CAAC,CAAD,CAAN,CAAW,EAAX,CAAD,CAAkB,EAHb,CAIL,CAJK,CAAP,CADG,IASA,IACFA,KAAK,CAAG,sDAAsDI,IAAtD,CAA2DP,KAA3D,CADN,CAGH,MAAO,CAAC,CAACG,KAAK,CAAC,CAAD,CAAP,CAAY,CAACA,KAAK,CAAC,CAAD,CAAlB,CAAuB,CAACA,KAAK,CAAC,CAAD,CAA7B,CAAkC,CAACA,KAAK,CAAC,CAAD,CAAxC,CAAP,CAHG,IAMA,IAAKA,KAAK,CAAG,iCAAiCI,IAAjC,CAAsCP,KAAtC,CAAb,CACH,MAAO,CAAC,CAACG,KAAK,CAAC,CAAD,CAAP,CAAY,CAACA,KAAK,CAAC,CAAD,CAAlB,CAAuB,CAACA,KAAK,CAAC,CAAD,CAA7B,CAAkC,CAAlC,CAAP,CADG,IAGA,MAAM,IAAIK,CAAAA,KAAJ,CAAUR,KAAK,CAAG,iCAAlB,CAAN,CACN,CAEM,QAASS,CAAAA,WAAT,CAAqBT,KAArB,CAA2C,CAChD,cAAeA,KAAK,CAAC,CAAD,CAApB,KAA2BA,KAAK,CAAC,CAAD,CAAhC,KAAuCA,KAAK,CAAC,CAAD,CAA5C,KAAmDA,KAAK,CAAC,CAAD,CAAxD,KACD,CAEM,QAASU,CAAAA,gBAAT,CACLC,MADK,CAELC,MAFK,CAGLC,QAHK,CAIE,CACP,MAAOF,CAAAA,MAAM,CAACG,GAAP,CAAW,SAACC,CAAD,CAAIC,CAAJ,QAAUD,CAAAA,CAAC,CAAG,CAACH,MAAM,CAACI,CAAD,CAAN,CAAYD,CAAb,EAAkBF,QAAhC,EAAX,CAAP,CACD","sourcesContent":["export type Color = number[];\n\nexport function parseColor(color: string | Color): Color {\n  if (Array.isArray(color)) return color;\n  let cache;\n  const p = parseInt;\n  color = color.replace(/\\s/g, ''); // Remove all spaces\n\n  // Checks for 6 digit hex and converts string to integer\n  if ((cache = /#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color)))\n    return [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), 1];\n  // Checks for 3 digit hex and converts string to integer\n  else if ((cache = /#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color)))\n    return [\n      p(cache[1], 16) * 17,\n      p(cache[2], 16) * 17,\n      p(cache[3], 16) * 17,\n      1,\n    ];\n  // Checks for rgba and converts string to\n  // integer/float using unary + operator to save bytes\n  else if (\n    (cache = /rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\n  )\n    return [+cache[1], +cache[2], +cache[3], +cache[4]];\n  // Checks for rgb and converts string to\n  // integer/float using unary + operator to save bytes\n  else if ((cache = /rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color)))\n    return [+cache[1], +cache[2], +cache[3], 1];\n  // Otherwise throw an exception to make debugging easier\n  else throw new Error(color + ' is not supported by parseColor');\n}\n\nexport function formatColor(color: Color): string {\n  return `rgba(${color[0]},${color[1]},${color[2]},${color[3]})`;\n}\n\nexport function interpolateColor(\n  color1: Color,\n  color2: Color,\n  position: number\n): Color {\n  return color1.map((c, i) => c + (color2[i] - c) * position);\n}\n"]}