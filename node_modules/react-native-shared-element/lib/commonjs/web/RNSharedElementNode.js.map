{"version":3,"sources":["RNSharedElementNode.ts"],"names":["RNSharedElementNode","domNode","isParent","ancestorDomNode","hideRefCount","hideOpacity","refCount","styleCache","styleCallbacks","contentCache","contentCallbacks","element","resolvedElement","style","opacity","Promise","resolve","push","fetchInitialStyle","console","debug","ancestor","resolvedAncestor","rect","getBoundingClientRect","ancestorRect","translateX","x","translateY","y","layout","Rect","width","height","RNSharedElementStyle","window","getComputedStyle","callbacks","forEach","callback","fetchInitialContent","RNSharedElementContent","getSize","size","content","childNodes","length","log","i","childNode","tagName"],"mappings":"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","sourcesContent":["import { RNSharedElementStyle } from './RNSharedElementStyle';\nimport { RNSharedElementContent } from './RNSharedElementContent';\nimport { Rect } from './Rect';\nimport { IHTMLElement } from './types';\n\nexport type RNSharedElementNodeStyleCallback = (\n  value: RNSharedElementStyle\n) => void;\nexport type RNSharedElementNodeContentCallback = (\n  value: RNSharedElementContent\n) => void;\n\nexport class RNSharedElementNode {\n  public readonly domNode: IHTMLElement;\n  public readonly ancestorDomNode: IHTMLElement;\n  public readonly isParent: boolean;\n  private hideRefCount: number = 0;\n  private hideOpacity: number = 0;\n  private refCount: number = 1;\n  private styleCache: RNSharedElementStyle | null = null;\n  private styleCallbacks: RNSharedElementNodeStyleCallback[] | null = null;\n  private contentCache: RNSharedElementContent | null = null;\n  private contentCallbacks: RNSharedElementNodeContentCallback[] | null = null;\n\n  constructor(\n    domNode: IHTMLElement,\n    isParent: boolean,\n    ancestorDomNode: IHTMLElement\n  ) {\n    this.domNode = domNode;\n    this.isParent = isParent;\n    this.ancestorDomNode = ancestorDomNode;\n  }\n\n  addRef() {\n    return ++this.refCount;\n  }\n\n  releaseRef() {\n    return --this.refCount;\n  }\n\n  addHideRef() {\n    this.hideRefCount++;\n    if (this.hideRefCount === 1) {\n      const element = this.resolvedElement;\n      this.hideOpacity = element!.style.opacity;\n      element!.style.opacity = 0;\n    }\n  }\n\n  releaseHideRef() {\n    this.hideRefCount--;\n    if (this.hideRefCount === 0) {\n      const element = this.resolvedElement;\n      element!.style.opacity = this.hideOpacity;\n    }\n  }\n\n  get resolvedElement(): IHTMLElement | null {\n    let element: IHTMLElement = this.domNode;\n\n    // If this node is a parent, look for the first child\n    if (this.isParent) {\n      if (element.childNodes.length === 1) {\n        element = element.childNodes[0];\n      } else if (element.childNodes.length <= 0) {\n        console.log('Child for parent doesnt exist');\n        return null;\n      }\n    }\n\n    // Get background-image node\n    const { childNodes } = element;\n    if (childNodes.length === 2) {\n      for (let i = 0; i < 2; i++) {\n        const childNode = childNodes[i];\n        if (childNode.tagName === 'IMG') {\n          element = childNodes[i ? 0 : i + 1];\n          break;\n        }\n      }\n    }\n\n    return element;\n  }\n\n  get resolvedAncestor(): IHTMLElement | null {\n    return this.ancestorDomNode;\n  }\n\n  requestStyle(): Promise<RNSharedElementStyle> {\n    if (this.styleCache) {\n      return Promise.resolve(this.styleCache);\n    }\n    return new Promise(resolve => {\n      this.styleCallbacks = this.styleCallbacks || [];\n      this.styleCallbacks.push(resolve);\n      if (!this.fetchInitialStyle()) {\n        console.debug('Failed to fetch style');\n        //startRetryLoop();\n      }\n    });\n  }\n\n  private fetchInitialStyle(): boolean {\n    const element = this.resolvedElement;\n    const ancestor = this.resolvedAncestor;\n    if (!element || !ancestor) return false;\n    if (!this.styleCallbacks) return true;\n\n    // Fetch layout\n    const rect = element.getBoundingClientRect();\n    // const ancestorTransform = ancestor.style.transform;\n    const ancestorRect = ancestor.getBoundingClientRect();\n    // console.log(\"ancestorTransform: \", ancestor.style, ancestorRect);\n    const translateX = ancestorRect.x; // TODO\n    const translateY = ancestorRect.y; // TODO\n    const layout = new Rect({\n      x: rect.x - translateX,\n      y: rect.y - translateY,\n      width: rect.width,\n      height: rect.height,\n    });\n\n    // Create style\n    const style = new RNSharedElementStyle(\n      layout,\n      // @ts-ignore\n      window.getComputedStyle(element, null)\n    );\n\n    // console.debug(\"Style fetched: \", style);\n\n    // Update cache\n    this.styleCache = style;\n\n    // Notify callbacks\n    const callbacks = this.styleCallbacks;\n    this.styleCallbacks = null;\n    callbacks.forEach(callback => callback(style));\n    return true;\n  }\n\n  async requestContent(): Promise<RNSharedElementContent> {\n    if (this.contentCache) return this.contentCache;\n\n    return new Promise(resolve => {\n      if (this.contentCallbacks) return;\n      this.contentCallbacks = this.contentCallbacks || [];\n      this.contentCallbacks.push(resolve);\n      this.fetchInitialContent();\n      // TODO RETRY IN CASE OF FAILURE?\n    });\n  }\n\n  private async fetchInitialContent(): Promise<boolean> {\n    const element = this.resolvedElement;\n    if (!element) return false;\n    if (!this.contentCallbacks) return true;\n\n    // Fetch content size\n    const size = await RNSharedElementContent.getSize(element);\n    if (!size) {\n      return false;\n    }\n\n    // Create content\n    const content = new RNSharedElementContent(element, size);\n\n    // console.debug(\"Content fetched: \", content);\n\n    // Update cache\n    this.contentCache = content;\n\n    // Notify callbacks\n    const callbacks = this.contentCallbacks;\n    this.contentCallbacks = null;\n    callbacks.forEach(callback => callback(content));\n    return true;\n  }\n}\n"]}